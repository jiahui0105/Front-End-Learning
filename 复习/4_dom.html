<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
    <!--
        1.this指向   给谁绑定了事件、方法，谁就是this
            1)在普通函数里 this->window
            2)在自定义的对象里 this->当前对象obj   var obj={}
            3)在定时器里 setTimeout this->window
            4)在类中 this->实例化对象
            5)在事件处理函数里 this->绑定该事件的dom对象
            6)箭头函数中  this->声明时的this   (父作用域中的this)

        2.事件三要素：事件源  事件执行函数  事件本身(事件对象)
            事件：鼠标单击、双击、滑入、滑出等

            事件对象event（包含着与这个事件相关的信息 属性 方法 ）
            事件处理函数 function
            事件源 e.target: 谁触发了这个事件，谁就是事件源（真正点击的）

            this：给谁绑定的事件 谁就是this （绑定事件的）
            e.currentTarget ：this

        3.事件机制
            事件的冒泡 从里向外。。
            事件的捕获 从外向里。。
            既有捕获又有冒泡时：先发生捕获事件，后发生冒泡事件。  先从外向里  再从里向外。。

            阻止冒泡：
                e.stopPropagation();  标准浏览器
                e.cancelBubble = true;  IE浏览器
            阻止默认行为
                e.preventDefault();   标准浏览器
                e.returnValue = false;  IE浏览器
                return false          所有浏览器都支持

        4.绑定事件
            onclick （只能绑定一次）如果给同一个元素绑定多次同种类型的事件，后面会覆盖前面的
            addEventListener('事件类型',function(){},true 事件捕获/false 事件冒泡);（可以给同一个元素绑定多次）

        5.事件委托： 解决后生成元素的事件绑定，把该事件绑定在已存在的父元素上。。当点击子元素时，通过事件冒泡  会冒泡到父元素上。
            优点1：定义函数只定义一次 然而for循环会执行多次 浪费空间
            优点2：有效解决后生成元素绑不上事件问题
    -->

<script></script>
</body>
</html>